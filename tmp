From 09f37be7cfd4ca8c942eadcc1fe8d50324a34d15 Mon Sep 17 00:00:00 2001
From: zhangmingyi <zhangmingyi5@huawei.com>
Date: Fri, 22 Aug 2025 15:34:13 +0800
Subject: [PATCH] lwip add flow and bond6 switch


diff --git a/src/core/ipv6/nd6.c b/src/core/ipv6/nd6.c
index 970ce40..24abaab 100644
--- a/src/core/ipv6/nd6.c
+++ b/src/core/ipv6/nd6.c
@@ -62,6 +62,11 @@
 #include "lwip/ip.h"
 #include "lwip/stats.h"
 #include "lwip/dns.h"
+#include "netif/ethernet.h"
+
+#if GAZELLE_ENABLE
+#include "lwipgz_offload.h"
+#endif
 
 #include <string.h>
 
@@ -292,6 +297,54 @@ nd6_process_autoconfig_prefix(struct netif *netif,
 }
 #endif /* LWIP_IPV6_AUTOCONFIG */
 
+#if GAZELLE_ENABLE
+/**
+ * When both flow_bifurcation and bond_mode 6 are enabled simultaneously,
+ * the IPv6 DAD (Duplicate Address Detection) message detection function
+ * may become confused, potentially receiving NS (Neighbor Solicitation)
+ * and NA (Neighbor Advertisement) messages that it itself has sent.
+ * Therefore, a detection mechanism is added here to avoid processing
+ * detection messages that are sent by itself. 
+ *
+ * @param p the nd packet, p->payload pointing to the icmpv6 header
+ * @param inp the netif on which this packet was received
+ */
+u8_t is_netif_mac(struct pbuf *p, struct netif *inp) {
+  if (!SYS_CONFIG(flow_bifurcation) || SYS_CONFIG(bond_mode) != 6) {
+    return 0;
+  }
+
+  int32_t port_id;
+  struct eth_hdr *ethhdr;
+  struct rte_ether_addr mac_addr;
+  int32_t nr_eth_dev = rte_eth_dev_count_avail();
+
+  pbuf_add_header(p, IP6_HLEN + SIZEOF_ETH_HDR);
+  ethhdr = (struct eth_hdr *)p->payload;
+  pbuf_remove_header(p, IP6_HLEN + SIZEOF_ETH_HDR);
+
+  LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_TRACE,
+          ("src mac:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F"\n",
+          (unsigned char)ethhdr->src.addr[0],  (unsigned char)ethhdr->src.addr[1],
+          (unsigned char)ethhdr->src.addr[2],  (unsigned char)ethhdr->src.addr[3],
+          (unsigned char)ethhdr->src.addr[4],  (unsigned char)ethhdr->src.addr[5]));
+
+    for (port_id = 0; port_id < nr_eth_dev; port_id++) {
+        rte_eth_macaddr_get(port_id, &mac_addr);
+        LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_TRACE,
+            ("nic mac:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\n",
+            mac_addr.addr_bytes[0], mac_addr.addr_bytes[1], mac_addr.addr_bytes[2],
+            mac_addr.addr_bytes[3], mac_addr.addr_bytes[4], mac_addr.addr_bytes[5]));
+        if (eth_addr_eq((struct eth_addr*)(&mac_addr), &ethhdr->src)){
+              LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_TRACE,("src mac is equal netif mac, message is from myself\n"));
+              return 1;
+        }
+    }
+
+  return 0;
+}
+#endif /* GAZELLE_ENABLE */
+
 /**
  * Process an incoming neighbor discovery message
  *
@@ -349,6 +402,10 @@ nd6_input(struct pbuf *p, struct netif *inp)
        * part of DAD mechanism? */
 
 #if LWIP_IPV6_DUP_DETECT_ATTEMPTS
+#if GAZELLE_ENABLE
+    if (!is_netif_mac(p, inp))
+#endif /* GAZELLE_ENABLE */
+    {
       /* If the target address matches this netif, it is a DAD response. */
       for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
         if (!ip6_addr_isinvalid(netif_ip6_addr_state(inp, i)) &&
@@ -361,6 +418,7 @@ nd6_input(struct pbuf *p, struct netif *inp)
           return;
         }
       }
+    }
 #endif /* LWIP_IPV6_DUP_DETECT_ATTEMPTS */
 
       /* Check that link-layer address option also fits in packet. */
diff --git a/src/include/arch/sys_arch.h b/src/include/arch/sys_arch.h
index 98d9ddf..75982e5 100644
--- a/src/include/arch/sys_arch.h
+++ b/src/include/arch/sys_arch.h
@@ -70,6 +70,8 @@ void sys_mempool_var_init(struct memp_desc *memp, char *desc, u16_t size, u16_t
 
 struct sys_config {
     bool rtc_mode;
+    bool flow_bifurcation;
+    int8_t bond_mode;
 };
 void sys_config_init(const struct sys_config *conf);
 extern const struct sys_config * const g_sys_config;
diff --git a/src/include/lwip/nd6.h b/src/include/lwip/nd6.h
index c30e624..7c4023f 100644
--- a/src/include/lwip/nd6.h
+++ b/src/include/lwip/nd6.h
@@ -50,6 +50,7 @@
 
 #include "lwip/ip6_addr.h"
 #include "lwip/err.h"
+#include "lwip/sys.h"
 
 #ifdef __cplusplus
 extern "C" {
-- 
2.33.0

